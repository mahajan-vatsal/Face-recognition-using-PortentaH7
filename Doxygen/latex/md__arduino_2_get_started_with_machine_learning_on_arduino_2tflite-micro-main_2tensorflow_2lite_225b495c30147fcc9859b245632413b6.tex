\chapter{001\+\_\+preallocated\+\_\+tensors}
\hypertarget{md__arduino_2_get_started_with_machine_learning_on_arduino_2tflite-micro-main_2tensorflow_2lite_225b495c30147fcc9859b245632413b6}{}\label{md__arduino_2_get_started_with_machine_learning_on_arduino_2tflite-micro-main_2tensorflow_2lite_225b495c30147fcc9859b245632413b6}\index{001\_preallocated\_tensors@{001\_preallocated\_tensors}}

\begin{DoxyItemize}
\item Pre-\/allocated tensors
\begin{DoxyItemize}
\item Background
\item Current status
\item Proposed implementation
\item Performance overview
\begin{DoxyItemize}
\item Cycle aspect
\item Memory aspect
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{md__arduino_2_get_started_with_machine_learning_on_arduino_2tflite-micro-main_2tensorflow_2lite_225b495c30147fcc9859b245632413b6_autotoc_md234}{}\doxysection{\texorpdfstring{Pre-\/allocated tensors}{Pre-\/allocated tensors}}\label{md__arduino_2_get_started_with_machine_learning_on_arduino_2tflite-micro-main_2tensorflow_2lite_225b495c30147fcc9859b245632413b6_autotoc_md234}
\hypertarget{md__arduino_2_get_started_with_machine_learning_on_arduino_2tflite-micro-main_2tensorflow_2lite_225b495c30147fcc9859b245632413b6_autotoc_md235}{}\doxysubsection{\texorpdfstring{Background}{Background}}\label{md__arduino_2_get_started_with_machine_learning_on_arduino_2tflite-micro-main_2tensorflow_2lite_225b495c30147fcc9859b245632413b6_autotoc_md235}
Tensors are allocated differently depending on the type of tensor. Weight tensors are located in the flatbuffer, which is allocated by the application that calls Tensor\+Flow Lite Micro. Eval\+Tensors are allocated in the tensor arena, either offline planned as specified in the flatbuffers metadata (described in this \href{https://docs.google.com/document/d/16aTSHL5wxsq99t6adVbBz1U3K8Y5tBDAvs16iroZDEU}{\texttt{ RFC}}), or allocated during runtime by the \href{https://github.com/tensorflow/tflite-micro/tree/main/tensorflow/lite/micro/memory_planner}{\texttt{ memory planner}} (online planned), see \href{https://docs.google.com/document/d/1akpqu0uiPQshmCrnV6dOEFgYM4tCCnI8Zce85PnjHMI}{\texttt{ RFC}}. The tensor arena is allocated by Micro\+Allocator in Tensor\+Flow Lite Micro, and the model buffer (represented by a .tflite-\/file) is allocated by the application using Tensor\+Flow Lite Micro. An illustration of this can be seen in the image below.



Is some use cases it could be advantageous to place some of the Eval\+Tensors outside of the tensor arena, for example\+: \texorpdfstring{$\ast$}{*} When sensor output data is stored in its own defined buffer, outside the tensor arena, and therefore needs to be copied into the tensor arena before inference. \texorpdfstring{$\ast$}{*} When the tensor is to be consumed from a memory location outside the tensor arena, e.\+g. a separate memory bank DSP. \textbackslash{} Details regarding the impact on the number of clock cycles and memory consumption can be found under “\+Performance overview”. In this RFC we present an option to allow an application to provide pre-\/allocated buffers to Tensor\+Flow Lite Micro for selected tensors. An illustration of the resulting memory layout with pre-\/allocated tensors can be seen in the figure below.

\hypertarget{md__arduino_2_get_started_with_machine_learning_on_arduino_2tflite-micro-main_2tensorflow_2lite_225b495c30147fcc9859b245632413b6_autotoc_md236}{}\doxysubsection{\texorpdfstring{Current status}{Current status}}\label{md__arduino_2_get_started_with_machine_learning_on_arduino_2tflite-micro-main_2tensorflow_2lite_225b495c30147fcc9859b245632413b6_autotoc_md236}
The purpose of pre-\/allocating tensors is to reduce the number of clock cycles, and our initial motivation for this feature was that avoiding the copying of the buffer described in the Background section would reduce the number of cycles consumed by the application.

Our second motivation was that by using a buffer outside of the memory arena, there was an opportunity to significantly reduce the required size of the memory arena.

An initial investigation into these matters, using the person detection model as an example, indicates that the performance gain might not be very significant in many use cases. The reduction in the number of clock cycles looks to be \texorpdfstring{$\sim$}{\string~}1\%. Details regarding this can be found in the Performance overview section.

The reduction in the size of the memory arena is not straightforward to estimate. As described in the Performance overview section, it depends on the size of other tensors in the network. In the worst case scenario it might not reduce the memory arena size at all. If the pre allocated buffer is much larger than the second largest buffer, then the reduction in size may be significant.

Therefore, our current position is that the performance gain expected from pre allocating the tensors does not motivate the increased complexity that this feature would introduce to the Tensor\+Flow Lite Micro framework.\hypertarget{md__arduino_2_get_started_with_machine_learning_on_arduino_2tflite-micro-main_2tensorflow_2lite_225b495c30147fcc9859b245632413b6_autotoc_md237}{}\doxysubsection{\texorpdfstring{Proposed implementation}{Proposed implementation}}\label{md__arduino_2_get_started_with_machine_learning_on_arduino_2tflite-micro-main_2tensorflow_2lite_225b495c30147fcc9859b245632413b6_autotoc_md237}
Micro\+Allocator initializes all tensors to nullptr, and during the allocation process only allocates the tensors whose data field is nullptr. The application tells the Micro\+Interpreter which tensor is preallocated, and supplies a memory buffer using the Register\+Preallocated\+Tensor() function.

The Micro\+Interpreter then assigns the pre-\/allocated buffer to the tensor data-\/field. If the tensor in question is marked as offline planned, as described in this \href{https://docs.google.com/document/d/16aTSHL5wxsq99t6adVbBz1U3K8Y5tBDAvs16iroZDEU}{\texttt{ RFC}}, the Micro\+Interpreter should not pre-\/allocated it, and instead return an error.

If multiple tensors are to be pre-\/allocated, multiple calls to Register\+Preallocated\+Tensor() are required. An example can be seen in the MSC below.

\hypertarget{md__arduino_2_get_started_with_machine_learning_on_arduino_2tflite-micro-main_2tensorflow_2lite_225b495c30147fcc9859b245632413b6_autotoc_md238}{}\doxysubsection{\texorpdfstring{Performance overview}{Performance overview}}\label{md__arduino_2_get_started_with_machine_learning_on_arduino_2tflite-micro-main_2tensorflow_2lite_225b495c30147fcc9859b245632413b6_autotoc_md238}
\hypertarget{md__arduino_2_get_started_with_machine_learning_on_arduino_2tflite-micro-main_2tensorflow_2lite_225b495c30147fcc9859b245632413b6_autotoc_md239}{}\doxysubsubsection{\texorpdfstring{Cycle aspect}{Cycle aspect}}\label{md__arduino_2_get_started_with_machine_learning_on_arduino_2tflite-micro-main_2tensorflow_2lite_225b495c30147fcc9859b245632413b6_autotoc_md239}
In this section we try to estimate the number of clock cycles one memcpy() takes in relation to the total inference time for the person\+\_\+detection model. The reason for looking closer at this model is that it has a relatively large input data size, which should make the cycle consumption of a memcpy() relatively large. Please note that these numbers are approximate and based on calculations, not actual benchmarking numbers.

A word aligned memcpy() consumes somewhere between 1 -\/ 4 bytes per cycle depending on which CPU is used. The input size for the person\+\_\+detection model is 96x96 = 9216 bytes. On a reference system without accelerators one memcpy() of 9216 bytes corresponds to, in order of magnitudes, \texorpdfstring{$\sim$}{\string~}0.01\% of the total amount of clock cycles for one inference. The ratio will differ depending on the input size and the number of inferences/second.

When using an accelerator, the total inference time will be significantly less which means that the memcpy()-\/call will consume a larger part of the total inference time. Approximations show that one memcpy() of 9216 bytes will consume \texorpdfstring{$\sim$}{\string~}1\% of the total execution time for a reference system utilizing an ML HW accelerator.\hypertarget{md__arduino_2_get_started_with_machine_learning_on_arduino_2tflite-micro-main_2tensorflow_2lite_225b495c30147fcc9859b245632413b6_autotoc_md240}{}\doxysubsubsection{\texorpdfstring{Memory aspect}{Memory aspect}}\label{md__arduino_2_get_started_with_machine_learning_on_arduino_2tflite-micro-main_2tensorflow_2lite_225b495c30147fcc9859b245632413b6_autotoc_md240}
In this section we\textquotesingle{}ll look at memory savings aspects of pre-\/allocating tensors outside the tensor arena. The default memory planner in TFLu is \href{https://github.com/tensorflow/tflite-micro/blob/main/tensorflow/lite/micro/memory_planner/greedy_memory_planner.h}{\texttt{ Greedy\+Planner}} (see \href{https://docs.google.com/document/d/1akpqu0uiPQshmCrnV6dOEFgYM4tCCnI8Zce85PnjHMI}{\texttt{ RFC}}). One good tool for understanding tensor layout in the tensor arena is using \href{https://github.com/tensorflow/tflite-micro/blob/73c5fa4d2bfbfd974552957818de2ab18ff42f39/tensorflow/lite/micro/memory_planner/greedy_memory_planner.h\#L84}{\texttt{ Print\+Memory\+Plan API}}. If we print the calculated memory layout for the \href{https://storage.googleapis.com/download.tensorflow.org/data/tf_lite_micro_person_data_int8_grayscale_2020_06_23.zip}{\texttt{ person detection model}}, the tensor arena looks like this at each layer\+:

{\ttfamily Layer 1\+: 00000000000000000000000000tttttttttttttt........................................ Layer 2\+: 00000000000000000000000000...........................999999999999999999999999999 Layer 3\+: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa999999999999999999999999999 Layer 4\+: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbb.............. Layer 5\+: cccccccccccccccccccccccccc...........................bbbbbbbbbbbbb.............. Layer 6\+: ccccccccccccccccccccccccccddddddddddddddddddddddddddd...........................}

The horizontal axis shows offset from the start of the tensor arena. The vertical axis shows execution order. The dots are "{}unused"{} memory for that specific layer. The letters and numbers represent the Eval\+Tensor index, mapped to 0-\/9, then a-\/z. \textquotesingle{}t\textquotesingle{} is the input tensor of layer 1 (equivalent to the input data to the model) and \textquotesingle{}0\textquotesingle{} is the output tensor of layer 1. Hence, \textquotesingle{}0\textquotesingle{} is also the input tensor to layer 2, and \textquotesingle{}9\textquotesingle{} is the output tensor of layer 2. And so on.

The reason for showing this illustration is that it becomes obvious that it is {\bfseries{the largest combination of simultaneously used tensors, of your model, that defines how large the tensor arena needs to be.}} In this example, it\textquotesingle{}s Layer 3.

The combined size of tensors \textquotesingle{}a\textquotesingle{} and \textquotesingle{}9\textquotesingle{} defines the size needed for the tensors arena. As a consequence, to save tensor arena memory by pre-\/allocation, we must start by pre-\/allocating tensor \textquotesingle{}a\textquotesingle{} or \textquotesingle{}9\textquotesingle{} outside the arena. This will make the total size of the tensor arena smaller, which will reduce the total memory footprint of Tensor\+Flow Lite Micro if the pre-\/allocated tensor is already allocated outside of the memory arena, like in the examples given in the Background section. 
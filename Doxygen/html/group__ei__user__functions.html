<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Machine Vision using Portenta H7: User-defined functions</title>
<link rel="icon" href="logo.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Machine Vision using Portenta H7<span id="projectnumber">&#160;2</span>
   </div>
   <div id="projectbrief">This project aims to develop a face recognition-based access control system using the Arduino Portenta H7 and Vision Shield, leveraging Edge Impulse for machine learning. The system captures facial images, processes them locally using an AI model deployed on the Portenta H7 and determines access based on authorised personnel.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">User-defined functions</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga98d553846de225d18f37c336772edb90" id="r_ga98d553846de225d18f37c336772edb90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ei__returntypes.html#gad9580b47a6cd5e74cfc31a03bdfecebe">EI_IMPULSE_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga98d553846de225d18f37c336772edb90">ei_sleep</a> (int32_t time_ms)</td></tr>
<tr class="memdesc:ga98d553846de225d18f37c336772edb90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancellable sleep, can be triggered with signal from other thread.  <br /></td></tr>
<tr class="separator:ga98d553846de225d18f37c336772edb90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac322f57a3b29b1118861626a156ee1c0" id="r_gac322f57a3b29b1118861626a156ee1c0"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac322f57a3b29b1118861626a156ee1c0">ei_read_timer_ms</a> ()</td></tr>
<tr class="memdesc:gac322f57a3b29b1118861626a156ee1c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the millisecond timer.  <br /></td></tr>
<tr class="separator:gac322f57a3b29b1118861626a156ee1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9aae7befaa896e21417df1f00518416" id="r_gac9aae7befaa896e21417df1f00518416"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac9aae7befaa896e21417df1f00518416">ei_read_timer_us</a> ()</td></tr>
<tr class="memdesc:gac9aae7befaa896e21417df1f00518416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the microsecond timer.  <br /></td></tr>
<tr class="separator:gac9aae7befaa896e21417df1f00518416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6358d33b5e41ab8b0f04cfb34e152b8" id="r_gad6358d33b5e41ab8b0f04cfb34e152b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad6358d33b5e41ab8b0f04cfb34e152b8">ei_putchar</a> (char c)</td></tr>
<tr class="memdesc:gad6358d33b5e41ab8b0f04cfb34e152b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a single character to the serial port.  <br /></td></tr>
<tr class="separator:gad6358d33b5e41ab8b0f04cfb34e152b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f5fbf070705027b9fe862091e746350" id="r_ga7f5fbf070705027b9fe862091e746350"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7f5fbf070705027b9fe862091e746350">ei_getchar</a> (void)</td></tr>
<tr class="memdesc:ga7f5fbf070705027b9fe862091e746350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single character from the serial port.  <br /></td></tr>
<tr class="separator:ga7f5fbf070705027b9fe862091e746350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2fc287a226b09cc30efe1aed55f1470" id="r_gad2fc287a226b09cc30efe1aed55f1470"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad2fc287a226b09cc30efe1aed55f1470">__attribute__</a> ((format(printf, 1, 2))) void <a class="el" href="ei__run__classifier_8h.html#adda641ea28ba092cca93ceb401fe0807">ei_printf</a>(const char *format</td></tr>
<tr class="memdesc:gad2fc287a226b09cc30efe1aed55f1470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print wrapper around printf()  <br /></td></tr>
<tr class="separator:gad2fc287a226b09cc30efe1aed55f1470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcb0babc6f41a7d0aa4c0801c96ae7e4" id="r_gadcb0babc6f41a7d0aa4c0801c96ae7e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadcb0babc6f41a7d0aa4c0801c96ae7e4">ei_printf_float</a> (float f)</td></tr>
<tr class="memdesc:gadcb0babc6f41a7d0aa4c0801c96ae7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to print floating point numbers.  <br /></td></tr>
<tr class="separator:gadcb0babc6f41a7d0aa4c0801c96ae7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71ecca5661ac4434a709c88e4c39b4aa" id="r_ga71ecca5661ac4434a709c88e4c39b4aa"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga71ecca5661ac4434a709c88e4c39b4aa">ei_malloc</a> (size_t <a class="el" href="hello__world__model_8cc.html#a439227feff9d7f55384e8780cfc2eb82">size</a>)</td></tr>
<tr class="memdesc:ga71ecca5661ac4434a709c88e4c39b4aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around malloc.  <br /></td></tr>
<tr class="separator:ga71ecca5661ac4434a709c88e4c39b4aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac69361ca85cf888be2ad7a700d5ff9cb" id="r_gac69361ca85cf888be2ad7a700d5ff9cb"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac69361ca85cf888be2ad7a700d5ff9cb">ei_calloc</a> (size_t nitems, size_t <a class="el" href="hello__world__model_8cc.html#a439227feff9d7f55384e8780cfc2eb82">size</a>)</td></tr>
<tr class="memdesc:gac69361ca85cf888be2ad7a700d5ff9cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around calloc.  <br /></td></tr>
<tr class="separator:gac69361ca85cf888be2ad7a700d5ff9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a6a70833407ff1870c12396ce2c4aa3" id="r_ga7a6a70833407ff1870c12396ce2c4aa3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7a6a70833407ff1870c12396ce2c4aa3">ei_free</a> (void *<a class="el" href="ei__aligned__malloc_8h.html#a0619a76ea2d4e6cce18b93ddf5082a36">ptr</a>)</td></tr>
<tr class="memdesc:ga7a6a70833407ff1870c12396ce2c4aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around free.  <br /></td></tr>
<tr class="separator:ga7a6a70833407ff1870c12396ce2c4aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>These functions are required to be implemented by the user for the target platform. See <a href="https://docs.edgeimpulse.com/docs/edge-ai-hardware/porting-guide">this porting guide</a> for more information. They are declared internally in the Edge Impulse C++ SDK library, and they must be defined by the user.</p>
<p><b>Source</b>: <a href="https://github.com/edgeimpulse/inferencing-sdk-cpp/blob/master/porting/ei_classifier_porting.h">porting/ei_classifier_porting.h</a></p>
<p><b>Examples</b>: The following examples demonstrate possible implementations of this function for various platforms. Note the <code>__attribute__((weak))</code> in most of the definitions, which means that a user could override the implementation elsewhere in the program:</p><ul>
<li><a href="https://github.com/edgeimpulse/inferencing-sdk-cpp/blob/master/porting/arduino/ei_classifier_porting.cpp">Arduino classifier porting</a></li>
<li><a href="https://github.com/edgeimpulse/inferencing-sdk-cpp/blob/master/porting/mbed/ei_classifier_porting.cpp">mbed classifier porting</a></li>
<li><a href="https://github.com/edgeimpulse/inferencing-sdk-cpp/blob/master/porting/posix/ei_classifier_porting.cpp">POSIX classifier porting</a></li>
<li><a href="https://github.com/edgeimpulse/inferencing-sdk-cpp/blob/master/porting/silabs/ei_classifier_porting.cpp">Silicon Labs classifier porting</a></li>
<li><a href="https://github.com/edgeimpulse/inferencing-sdk-cpp/blob/master/porting/stm32-cubeai/ei_classifier_porting.cpp">STM32 classifier porting</a></li>
<li><a href="https://github.com/edgeimpulse/inferencing-sdk-cpp/blob/master/porting/ti/debug_log.cpp">TI classifier porting</a></li>
<li><a href="https://github.com/edgeimpulse/inferencing-sdk-cpp/blob/master/porting/zephyr/ei_classifier_porting.cpp">Zephyr classifier porting</a></li>
</ul>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad2fc287a226b09cc30efe1aed55f1470" name="gad2fc287a226b09cc30efe1aed55f1470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2fc287a226b09cc30efe1aed55f1470">&#9670;&#160;</a></span>__attribute__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__attribute__ </td>
          <td>(</td>
          <td class="paramtype">(format(printf, 1, 2))</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print wrapper around printf() </p>
<p><code><a class="el" href="ei__run__classifier_8h.html#adda641ea28ba092cca93ceb401fe0807">ei_printf()</a></code> is declared internally to the Edge Impulse SDK library so that debugging information (e.g. during inference) can be printed out. However, the function must be defined by the user, as printing methods can change depending on the platform and use case. For example, you may want to print debugging information to stdout in Linux or over a UART serial port on a microcontroller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Pointer to a character array or string that should be printed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Other optional arguments may be passed as necessary (e.g. handle to a UART object). Note that any calls to <code><a class="el" href="ei__run__classifier_8h.html#adda641ea28ba092cca93ceb401fe0807">ei_printf()</a></code> from within the <em>edge-impulse-sdk</em> library do not pass anything other than the <code>format</code> argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac69361ca85cf888be2ad7a700d5ff9cb" name="gac69361ca85cf888be2ad7a700d5ff9cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac69361ca85cf888be2ad7a700d5ff9cb">&#9670;&#160;</a></span>ei_calloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ei_calloc </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nitems</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around calloc. </p>
<p>This function should allocate <code>nitems * size</code> bytes and initialize all bytes in this allocated memory to 0. It should return a pointer to the allocated memory. In bare-metal implementations, it can simply be a wrapper for <code>calloc()</code>. For example:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="_i_m_u_capture_model_8ino.html#ac49da57b77b1d1aa2e10508eea61c957">__attribute__</a>((weak)) <span class="keywordtype">void</span> *<a class="code hl_function" href="#gac69361ca85cf888be2ad7a700d5ff9cb">ei_calloc</a>(<span class="keywordtype">size_t</span> nitems, <span class="keywordtype">size_t</span> <a class="code hl_variable" href="hello__world__model_8cc.html#a439227feff9d7f55384e8780cfc2eb82">size</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> calloc(nitems, <a class="code hl_variable" href="hello__world__model_8cc.html#a439227feff9d7f55384e8780cfc2eb82">size</a>);</div>
<div class="line">}</div>
<div class="ttc" id="a_i_m_u_capture_model_8ino_html_ac49da57b77b1d1aa2e10508eea61c957"><div class="ttname"><a href="_i_m_u_capture_model_8ino.html#ac49da57b77b1d1aa2e10508eea61c957">__attribute__</a></div><div class="ttdeci">byte tensorArena[tensorArenaSize] __attribute__((aligned(16)))</div></div>
<div class="ttc" id="agroup__ei__user__functions_html_gac69361ca85cf888be2ad7a700d5ff9cb"><div class="ttname"><a href="#gac69361ca85cf888be2ad7a700d5ff9cb">ei_calloc</a></div><div class="ttdeci">void * ei_calloc(size_t nitems, size_t size)</div><div class="ttdoc">Wrapper around calloc.</div></div>
<div class="ttc" id="ahello__world__model_8cc_html_a439227feff9d7f55384e8780cfc2eb82"><div class="ttname"><a href="hello__world__model_8cc.html#a439227feff9d7f55384e8780cfc2eb82">size</a></div><div class="ttdeci">int size</div><div class="ttdef"><b>Definition</b> hello_world_model.cc:113</div></div>
</div><!-- fragment --><p>If you intend to run your impulse in a multi-threaded environment, you will need to ensure that your implementation of <code><a class="el" href="#gac69361ca85cf888be2ad7a700d5ff9cb" title="Wrapper around calloc.">ei_calloc()</a></code> is thread-safe. For example, if you are using FreeRTOS, here is one possible implementation:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="_i_m_u_capture_model_8ino.html#ac49da57b77b1d1aa2e10508eea61c957">__attribute__</a>((weak)) <span class="keywordtype">void</span> *<a class="code hl_function" href="#gac69361ca85cf888be2ad7a700d5ff9cb">ei_calloc</a>(<span class="keywordtype">size_t</span> nitems, <span class="keywordtype">size_t</span> <a class="code hl_variable" href="hello__world__model_8cc.html#a439227feff9d7f55384e8780cfc2eb82">size</a>) {</div>
<div class="line">    <span class="keywordtype">void</span> *<a class="code hl_variable" href="ei__aligned__malloc_8h.html#a0619a76ea2d4e6cce18b93ddf5082a36">ptr</a> = NULL;</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_variable" href="hello__world__model_8cc.html#a439227feff9d7f55384e8780cfc2eb82">size</a> &gt; 0) {</div>
<div class="line">        <a class="code hl_variable" href="ei__aligned__malloc_8h.html#a0619a76ea2d4e6cce18b93ddf5082a36">ptr</a> = pvPortMalloc(nitems * <a class="code hl_variable" href="hello__world__model_8cc.html#a439227feff9d7f55384e8780cfc2eb82">size</a>);</div>
<div class="line">        <span class="keywordflow">if</span>(<a class="code hl_variable" href="ei__aligned__malloc_8h.html#a0619a76ea2d4e6cce18b93ddf5082a36">ptr</a>)</div>
<div class="line">           memset(<a class="code hl_variable" href="ei__aligned__malloc_8h.html#a0619a76ea2d4e6cce18b93ddf5082a36">ptr</a>, 0, (nitems * <a class="code hl_variable" href="hello__world__model_8cc.html#a439227feff9d7f55384e8780cfc2eb82">size</a>));</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_variable" href="ei__aligned__malloc_8h.html#a0619a76ea2d4e6cce18b93ddf5082a36">ptr</a>;</div>
<div class="line">}</div>
<div class="ttc" id="aei__aligned__malloc_8h_html_a0619a76ea2d4e6cce18b93ddf5082a36"><div class="ttname"><a href="ei__aligned__malloc_8h.html#a0619a76ea2d4e6cce18b93ddf5082a36">ptr</a></div><div class="ttdeci">return ptr</div><div class="ttdef"><b>Definition</b> ei_aligned_malloc.h:80</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nitems</td><td>Number of blocks to allocate and clear </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size (in bytes) of each block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7a6a70833407ff1870c12396ce2c4aa3" name="ga7a6a70833407ff1870c12396ce2c4aa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a6a70833407ff1870c12396ce2c4aa3">&#9670;&#160;</a></span>ei_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ei_free </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around free. </p>
<p>This function should free the memory space pointed to by <code>ptr</code>. If <code>ptr</code> is <code>NULL</code>, no operation should be performed. In bare-metal implementations, it can simply be a wrapper for <code>free()</code>. For example:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="_i_m_u_capture_model_8ino.html#ac49da57b77b1d1aa2e10508eea61c957">__attribute__</a>((weak)) <span class="keywordtype">void</span> <a class="code hl_function" href="#ga7a6a70833407ff1870c12396ce2c4aa3">ei_free</a>(<span class="keywordtype">void</span> *<a class="code hl_variable" href="ei__aligned__malloc_8h.html#a0619a76ea2d4e6cce18b93ddf5082a36">ptr</a>) {</div>
<div class="line">    free(<a class="code hl_variable" href="ei__aligned__malloc_8h.html#a0619a76ea2d4e6cce18b93ddf5082a36">ptr</a>);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__ei__user__functions_html_ga7a6a70833407ff1870c12396ce2c4aa3"><div class="ttname"><a href="#ga7a6a70833407ff1870c12396ce2c4aa3">ei_free</a></div><div class="ttdeci">void ei_free(void *ptr)</div><div class="ttdoc">Wrapper around free.</div></div>
</div><!-- fragment --><p>If you intend to run your impulse in a multi-threaded environment, you will need to ensure that your implementation of <code><a class="el" href="#ga7a6a70833407ff1870c12396ce2c4aa3" title="Wrapper around free.">ei_free()</a></code> is thread-safe. For example, if you are using FreeRTOS, here is one possible implementation:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="_i_m_u_capture_model_8ino.html#ac49da57b77b1d1aa2e10508eea61c957">__attribute__</a>((weak)) <span class="keywordtype">void</span> <a class="code hl_function" href="#ga7a6a70833407ff1870c12396ce2c4aa3">ei_free</a>(<span class="keywordtype">void</span> *<a class="code hl_variable" href="ei__aligned__malloc_8h.html#a0619a76ea2d4e6cce18b93ddf5082a36">ptr</a>) {</div>
<div class="line">    pvPortFree(<a class="code hl_variable" href="ei__aligned__malloc_8h.html#a0619a76ea2d4e6cce18b93ddf5082a36">ptr</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Pointer to the memory to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7f5fbf070705027b9fe862091e746350" name="ga7f5fbf070705027b9fe862091e746350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f5fbf070705027b9fe862091e746350">&#9670;&#160;</a></span>ei_getchar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ei_getchar </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a single character from the serial port. </p>
<dl class="section return"><dt>Returns</dt><dd>The character read from the serial port </dd></dl>

</div>
</div>
<a id="ga71ecca5661ac4434a709c88e4c39b4aa" name="ga71ecca5661ac4434a709c88e4c39b4aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71ecca5661ac4434a709c88e4c39b4aa">&#9670;&#160;</a></span>ei_malloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ei_malloc </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around malloc. </p>
<p>This function should allocate <code>size</code> bytes and return a pointer to the allocated memory. In bare-metal implementations, it can simply be a wrapper for <code>malloc()</code>. For example:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="_i_m_u_capture_model_8ino.html#ac49da57b77b1d1aa2e10508eea61c957">__attribute__</a>((weak)) <span class="keywordtype">void</span> *<a class="code hl_function" href="#ga71ecca5661ac4434a709c88e4c39b4aa">ei_malloc</a>(<span class="keywordtype">size_t</span> <a class="code hl_variable" href="hello__world__model_8cc.html#a439227feff9d7f55384e8780cfc2eb82">size</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> malloc(<a class="code hl_variable" href="hello__world__model_8cc.html#a439227feff9d7f55384e8780cfc2eb82">size</a>);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__ei__user__functions_html_ga71ecca5661ac4434a709c88e4c39b4aa"><div class="ttname"><a href="#ga71ecca5661ac4434a709c88e4c39b4aa">ei_malloc</a></div><div class="ttdeci">void * ei_malloc(size_t size)</div><div class="ttdoc">Wrapper around malloc.</div></div>
</div><!-- fragment --><p>If you intend to run your impulse in a multi-threaded environment, you will need to ensure that your implementation of <code><a class="el" href="#ga71ecca5661ac4434a709c88e4c39b4aa" title="Wrapper around malloc.">ei_malloc()</a></code> is thread-safe. For example, if you are using FreeRTOS, here is one possible implementation:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="_i_m_u_capture_model_8ino.html#ac49da57b77b1d1aa2e10508eea61c957">__attribute__</a>((weak)) <span class="keywordtype">void</span> *<a class="code hl_function" href="#ga71ecca5661ac4434a709c88e4c39b4aa">ei_malloc</a>(<span class="keywordtype">size_t</span> <a class="code hl_variable" href="hello__world__model_8cc.html#a439227feff9d7f55384e8780cfc2eb82">size</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> pvPortMalloc(<a class="code hl_variable" href="hello__world__model_8cc.html#a439227feff9d7f55384e8780cfc2eb82">size</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of bytes to allocate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadcb0babc6f41a7d0aa4c0801c96ae7e4" name="gadcb0babc6f41a7d0aa4c0801c96ae7e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcb0babc6f41a7d0aa4c0801c96ae7e4">&#9670;&#160;</a></span>ei_printf_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ei_printf_float </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to print floating point numbers. </p>
<p>Some platforms cannot handle directly printing floating point numbers (e.g. to a console or over a serial port). If your platform cannot directly print floats, provide an implementation of this function to print them as needed (for example, construct a string containing scientific notation with integers and call <code><a class="el" href="ei__run__classifier_8h.html#adda641ea28ba092cca93ceb401fe0807">ei_printf()</a></code>).</p>
<p>If your platform can print floating point values, the easiest implementation of this function is as follows:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="_i_m_u_capture_model_8ino.html#ac49da57b77b1d1aa2e10508eea61c957">__attribute__</a>((weak)) <span class="keywordtype">void</span> <a class="code hl_function" href="#gadcb0babc6f41a7d0aa4c0801c96ae7e4">ei_printf_float</a>(<span class="keywordtype">float</span> f) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;%f&quot;</span>, f);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__ei__user__functions_html_gadcb0babc6f41a7d0aa4c0801c96ae7e4"><div class="ttname"><a href="#gadcb0babc6f41a7d0aa4c0801c96ae7e4">ei_printf_float</a></div><div class="ttdeci">void ei_printf_float(float f)</div><div class="ttdoc">Used to print floating point numbers.</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The floating point number to print </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad6358d33b5e41ab8b0f04cfb34e152b8" name="gad6358d33b5e41ab8b0f04cfb34e152b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6358d33b5e41ab8b0f04cfb34e152b8">&#9670;&#160;</a></span>ei_putchar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ei_putchar </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a single character to the serial port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The chararater to send </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac322f57a3b29b1118861626a156ee1c0" name="gac322f57a3b29b1118861626a156ee1c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac322f57a3b29b1118861626a156ee1c0">&#9670;&#160;</a></span>ei_read_timer_ms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ei_read_timer_ms </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the millisecond timer. </p>
<p>Read the millisecond timer </p>
<p>This function should return the number of milliseconds that have passed since the start of the program. If you do not need to determine the run times for DSP and inference blocks, you can simply return 0 from this function. Your impulse will still work correctly without timing information.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of milliseconds that have passed since the start of the program </dd></dl>

</div>
</div>
<a id="gac9aae7befaa896e21417df1f00518416" name="gac9aae7befaa896e21417df1f00518416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9aae7befaa896e21417df1f00518416">&#9670;&#160;</a></span>ei_read_timer_us()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ei_read_timer_us </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the microsecond timer. </p>
<p>This function should return the number of milliseconds that have passed since the start of the program. If you do not need to determine the run times for DSP and inference blocks, you can simply return 0 from this function. Your impulse will still work correctly without timing information.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of microseconds that have passed since the start of the program </dd></dl>

</div>
</div>
<a id="ga98d553846de225d18f37c336772edb90" name="ga98d553846de225d18f37c336772edb90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98d553846de225d18f37c336772edb90">&#9670;&#160;</a></span>ei_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ei__returntypes.html#gad9580b47a6cd5e74cfc31a03bdfecebe">EI_IMPULSE_ERROR</a> ei_sleep </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>time_ms</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancellable sleep, can be triggered with signal from other thread. </p>
<p>Cancelable sleep, can be triggered with signal from other thread </p>
<p>Allow the processor or thread to sleep or block for the given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">time_ms</td><td>Time in milliseconds to sleep</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>EI_IMPULSE_OK</code> if successful, error code otherwise </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>

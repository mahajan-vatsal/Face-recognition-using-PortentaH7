<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Machine Vision using Portenta H7: Person Detection Training</title>
<link rel="icon" href="logo.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Machine Vision using Portenta H7<span id="projectnumber">&#160;2</span>
   </div>
   <div id="projectbrief">This project aims to develop a face recognition-based access control system using the Arduino Portenta H7 and Vision Shield, leveraging Edge Impulse for machine learning. The system captures facial images, processes them locally using an AI model deployed on the Portenta H7 and determines access based on authorised personnel.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">Person Detection Training</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md298"></a></p>
<p>In this document, you will learn how to generate a 250 KB binary classification model to detect if a person is present in an input image or not.</p>
<h1><a class="anchor" id="autotoc_md299"></a>
Resources</h1>
<h2><a class="anchor" id="autotoc_md300"></a>
Trained model</h2>
<p>The trained model file (C source file <code>person_detect_model_data.cc</code>) used in this example to run person detection on various microcontrollers is available in <a href="https://storage.googleapis.com/download.tensorflow.org/data/tf_lite_micro_person_data_int8_grayscale_2020_01_13.zip">person_detection.zip</a>. This document shows you how to generate the model file.</p>
<h2><a class="anchor" id="autotoc_md301"></a>
Dataset</h2>
<p>We use the <a href="https://arxiv.org/abs/1906.05721">Visual Wake Words dataset</a> which contains images that belong to two classes (person or not-person). This dataset is designed to be useful for benchmarking and testing embedded computer vision, since it represents a very common task, i.e, binary classification, that we need to accomplish with tight resource constraints. We're hoping to see it drive even better models for this and similar tasks.</p>
<p>This is a large download (~40GB), so you'll need to make sure you have at least 100GB free on your drive to allow space for unpacking and further processing.</p>
<h2><a class="anchor" id="autotoc_md302"></a>
Model Architecture</h2>
<p><a href="https://arxiv.org/abs/1704.04861">MobileNets</a> are a family of efficient Convolutional Neural Networks for Mobile Vision, designed to provide good accuracy for as few weight parameters and arithmetic operations as possible.</p>
<h2><a class="anchor" id="autotoc_md303"></a>
Compute</h2>
<p>This model will take several hours to train on a powerful machine with GPUs and several days with CPUs. Alternatively, we recommend using a <a href="https://cloud.google.com/deep-learning-vm/">Google Cloud Deep Learning VM</a> or <a href="https://colab.research.google.com/signup">Google Colab Pro</a> for faster training.</p>
<h2><a class="anchor" id="autotoc_md304"></a>
Framework</h2>
<p>We'll be training the models using the Slim library in TensorFlow 1. It is still widely used but deprecated, so future versions of TensorFlow may not support this approach.</p>
<p>Keras is the recommended interface for building models in TensorFlow 2 and future versions, but does not support all the features we need to build the person detection model. We hope to publish Keras instructions in the future.</p>
<h1><a class="anchor" id="autotoc_md305"></a>
Code</h1>
<h2><a class="anchor" id="autotoc_md306"></a>
Setup</h2>
<p>We will be running all commands from your home directory. You can place the repository somewhere else, but you'll need to update all references to it. Now run this step initially:</p>
<div class="fragment"><div class="line">! cd ~</div>
</div><!-- fragment --><p>Clone the <a href="https://github.com/tensorflow/models">TensorFlow models</a> github repository:</p>
<div class="fragment"><div class="line">! git clone https://github.com/tensorflow/models.git</div>
</div><!-- fragment --><p>Specifically, we will be using <code>~/models/research/slim</code> a <a href="https://github.com/tensorflow/models/tree/master/research/slim">library</a> for defining, training and evaluating models. However, in order to use it, you'll need to make sure its modules can be found by Python, and install one dependency. Here's how to do this in an iPython notebook:</p>
<div class="fragment"><div class="line">! pip install contextlib2</div>
<div class="line">import os</div>
<div class="line">new_python_path = (os.environ.get(&quot;PYTHONPATH&quot;) or &#39;&#39;) + &quot;:models/research/slim&quot;</div>
<div class="line">%env PYTHONPATH=$new_python_path</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md307"></a>
Download the Dataset</h2>
<p>The <a href="https://arxiv.org/abs/1906.05721">Visual Wake Words dataset</a> contains images which belong to two classes: person (labelled as 1) and not-person (labelled as 0) and it is derived from the <a href="http://cocodataset.org/#explore">COCO dataset</a> containing 80 categories (eg: cat, dog, umbrella, etc). You can download the dataset by running this script:</p>
<div class="fragment"><div class="line">! python models/research/slim/download_and_convert_data.py \</div>
<div class="line">--logtostderr \</div>
<div class="line">--dataset_name=visualwakewords \</div>
<div class="line">--dataset_dir=person_detection_dataset \</div>
<div class="line">--foreground_class_of_interest=&#39;person&#39; \</div>
<div class="line">--small_object_area_threshold=0.005</div>
</div><!-- fragment --><p>This will take several minutes (~20 minutes or more) so you may have to wait for a while before you proceed onto the next part. When it's done, you'll have a set of TFRecords in the <code>person_detection_dataset/</code> directory holding the labeled image information.</p>
<p>The script takes a long time as the COCO dataset does not have a label for each image, instead each image comes with a list of labelled bounding boxes. To create the Visual WakeWords dataset, we loop over every image and its bounding boxes and if an image has at least one bounding box labelled as 'person' with an area greater than 0.5% of the area of the image, then the entire image is labelled as "person", otherwise it is labelled as "non-person".</p>
<h2><a class="anchor" id="autotoc_md308"></a>
Train the model</h2>
<div class="fragment"><div class="line">! python models/research/slim/train_image_classifier.py \</div>
<div class="line">    --alsologtostderr \</div>
<div class="line">    --dataset_name=visualwakewords \</div>
<div class="line">    --dataset_dir=person_detection_dataset \</div>
<div class="line">    --dataset_split_name=train \</div>
<div class="line">    --train_image_size=96 \</div>
<div class="line">    --use_grayscale=True \</div>
<div class="line">    --preprocessing_name=mobilenet_v1 \</div>
<div class="line">    --model_name=mobilenet_v1_025 \</div>
<div class="line">    --train_dir=person_detection_train \</div>
<div class="line">    --save_summaries_secs=300 \</div>
<div class="line">    --learning_rate=0.045 \</div>
<div class="line">    --label_smoothing=0.1 \</div>
<div class="line">    --learning_rate_decay_factor=0.98 \</div>
<div class="line">    --num_epochs_per_decay=2.5 \</div>
<div class="line">    --moving_average_decay=0.9999 \</div>
<div class="line">    --batch_size=96 \</div>
<div class="line">    --max_number_of_steps=1000000</div>
</div><!-- fragment --><p>This will take a couple of days on a single-GPU v100 instance to complete all one-million steps, but you should be able to get a fairly accurate model after a few hours if you want to experiment early.</p>
<ul>
<li><code>--dataset_dir</code> parameter should match the one where you saved the TFRecords from the Visual Wake Words build script from the previous step.</li>
<li><code>--preprocessing_name</code> controls how input images are modified before they're fed into the model. It reduces each image to the size specified by <code>--train_image_size</code> (here 96), convert them to grayscale using <code>--use_grayscale=True</code> which is compatible with the monochrome <a href="https://himax.com.tw/products/cmos-image-sensor/image-sensors/hm01b0/">HM01B0</a> camera we're using on the SparkFun Edge board and scale the pixel values from 0 to 255 integers into -1.0 to +1.0 floating point numbers (which will be <a href="https://en.wikipedia.org/wiki/Quantization">quantized</a> after training).</li>
<li><code>--model_name</code> is the model architecture we'll be using; here it's <code>mobilenet_v1_025</code>. The 'mobilenet_v1' prefix tells the script to use the first version of MobileNet. We use V1 as it uses the least amount of RAM for its intermediate activation buffers compared to later versions. The '025' is the depth multiplier, which reduces the number of weight parameters. This low setting ensures the model fits within 250KB of Flash.</li>
<li><code>--train_dir</code> will contain the trained checkpoints and summaries.</li>
<li>The <code>--learning_rate</code>, <code>--label_smoothing</code>, <code>--learning_rate_decay_factor</code>, <code>--num_epochs_per_decay</code>, <code>--moving_average_decay</code> and <code>--batch_size</code> are all parameters that control how weights are updated during the training process. Training deep networks is still a bit of a dark art, so these exact values we found through experimentation for this particular model. You can try tweaking them to speed up training or gain a small boost in accuracy, but we can't give much guidance for how to make those changes, and it's easy to get combinations where the training accuracy never converges.</li>
<li>The <code>--max_number_of_steps</code> defines how long the training should continue. There's no good way to figure out this threshold in advance, you have to experiment to tell when the accuracy of the model is no longer improving to tell when to cut it off. In our case we default to a million steps, since with this particular model we know that's a good point to stop.</li>
</ul>
<p>Once you start the script, you should see output that looks something like this:</p>
<div class="fragment"><div class="line">INFO:tensorflow:global step 4670: loss = 0.7112 (0.251 sec/step)</div>
<div class="line">I0928 00:16:21.774756 140518023943616 learning.py:507] global step 4670: loss =</div>
<div class="line">0.7112 (0.251 sec/step)</div>
<div class="line">INFO:tensorflow:global step 4680: loss = 0.6596 (0.227 sec/step)</div>
<div class="line">I0928 00:16:24.365901 140518023943616 learning.py:507] global step 4680: loss =</div>
<div class="line">0.6596 (0.227 sec/step)</div>
</div><!-- fragment --><p>Don't worry about the line duplication, this is just a side-effect of the way TensorFlow log printing interacts with Python. Each line has two key bits of information about the training process.</p><ol type="1">
<li>The <code>global step</code> is a count of how far through the training we are. Since we've set the limit as a million steps, in this case we're nearly five percent complete. The steps per second estimate is also useful, since you can use it to estimate a rough duration for the whole training process. In this case, we're completing about four steps a second, so a million steps will take about 70 hours, or three days.</li>
<li>The <code>loss</code> is a measure of how close the partially-trained model's predictions are to the correct values, and lower values are <em>better</em>. This will show a lot of variation but should on an average decrease during training if the model is learning. This kind of variation is a lot easier to see in a graph, which is one of the main reasons to try TensorBoard.</li>
</ol>
<h3><a class="anchor" id="autotoc_md309"></a>
TensorBoard</h3>
<p>TensorBoard is a web application that lets you view data visualizations from TensorFlow training sessions. You can start Tensorboard using the command line: Run: <code>tensorboard --logdir person_detection_train</code>. Go to the URL it provides.</p>
<p>It may take a little while for the graphs to have anything useful in them, since the script only saves summaries every five minutes (or 300 seconds). The most important graph is called <code>clone_loss</code> and this shows the progression of the same loss value that's displayed on the logging output. It fluctuates a lot, but the overall trend is downwards over time. If you don't see this sort of progression after a few hours of training, it's a sign that your model isn't converging to a good solution, and you may need to debug what's going wrong either with your dataset or the training parameters.</p>
<p>TensorBoard defaults to the 'Scalars' tab when it opens, but the other section that can be useful during training is 'Images'. This shows a random selection of the pictures the model is currently being trained on, including any distortions and other preprocessing. This information isn't as essential as the loss graphs, but it can be useful to ensure the dataset is what you expect, and it is interesting to see the examples updating as training progresses.</p>
<h2><a class="anchor" id="autotoc_md310"></a>
Evaluate the model</h2>
<p>(You don't need to wait until the model is fully trained, you can check the accuracy of any checkpoints in the <code>--train_dir</code> folder.)</p>
<div class="fragment"><div class="line">! python models/research/slim/eval_image_classifier.py \</div>
<div class="line">    --alsologtostderr \</div>
<div class="line">    --dataset_name=visualwakewords \</div>
<div class="line">    --dataset_dir=person_detection_train \</div>
<div class="line">    --dataset_split_name=val \</div>
<div class="line">    --eval_image_size=96 \</div>
<div class="line">    --use_grayscale=True \</div>
<div class="line">    --preprocessing_name=mobilenet_v1 \</div>
<div class="line">    --model_name=mobilenet_v1_025 \</div>
<div class="line">    --train_dir=person_detection_train \</div>
<div class="line">    --checkpoint_path=person_detection_train/model.ckpt-123456</div>
</div><!-- fragment --><p>You'll need to make sure that <code>--checkpoint_path</code> is pointing to a valid set of checkpoint data. Checkpoints are stored in three separate files, so the value should be their common prefix. For example if you have a checkpoint file called 'model.ckpt-5179.data-00000-of-00001', the prefix would be 'model.ckpt-5179'. The script should produce output that looks something like this:</p>
<div class="fragment"><div class="line">INFO:tensorflow:Evaluation [406/406]</div>
<div class="line">I0929 22:52:59.936022 140225887045056 evaluation.py:167] Evaluation [406/406]</div>
<div class="line">eval/Accuracy[0.717438412]eval/Recall_5[1]</div>
</div><!-- fragment --><p>The important number here is the accuracy. It shows the proportion of the images that were classified correctly, which is 72% in this case, after converting to a percentage. If you follow the example script, you should expect a fully-trained model to achieve an accuracy of around 84% after one million steps, and show a loss of around 0.4.</p>
<h2><a class="anchor" id="autotoc_md311"></a>
Convert the TF model to a TF Lite model for Inference</h2>
<p>When the model has trained to an accuracy you're happy with, you'll need to convert the results from the TensorFlow training environment into a form you can run on an embedded device. As we've seen in previous chapters, this can be a complex process, and tf.slim adds a few of its own wrinkles too.</p>
<h3><a class="anchor" id="autotoc_md312"></a>
Generate the model graph</h3>
<p>Slim generates the architecture from the <code>model_name</code> every time one of its scripts is run, so for a model to be used outside of Slim it needs to be saved in a common format. We're going to use the GraphDef protobuf serialization format, since that's understood by both Slim and the rest of TensorFlow. This contains the layout of the operations in the model, but doesn't yet have any of the weight data.</p>
<div class="fragment"><div class="line">! python models/research/slim/export_inference_graph.py \</div>
<div class="line">    --alsologtostderr \</div>
<div class="line">    --dataset_name=visualwakewords \</div>
<div class="line">    --image_size=96 \</div>
<div class="line">    --use_grayscale=True \</div>
<div class="line">    --model_name=mobilenet_v1_025 \</div>
<div class="line">    --output_file=person_detection_graph.pb</div>
</div><!-- fragment --><p>You should have a new 'person_detection_graph.pb' file in your home folder.</p>
<h3><a class="anchor" id="autotoc_md313"></a>
Generate the frozen model graph (combine model graph and trained weights)</h3>
<p>The process of storing the trained weights together with the operation graph is known as freezing. This converts all of the variables in the graph to constants, after loading their values from a checkpoint file. The command below uses a checkpoint from the millionth training step, but you can supply any valid checkpoint path. The graph freezing script is stored inside the main TensorFlow repository, so we have to download this from GitHub before running this command.</p>
<div class="fragment"><div class="line">! git clone https://github.com/tensorflow/tensorflow</div>
<div class="line">! python tensorflow/tensorflow/python/tools/freeze_graph.py \</div>
<div class="line">--input_graph=person_detection_graph.pb \</div>
<div class="line">--input_checkpoint=person_detection_train/model.ckpt-1000000 \</div>
<div class="line">--input_binary=true \</div>
<div class="line">--output_node_names=MobilenetV1/Predictions/Reshape_1 \</div>
<div class="line">--output_graph=person_detection_frozen_graph.pb</div>
</div><!-- fragment --><p>After this, you should see a file called <code>person_detection_frozen_graph.pb</code></p>
<h3><a class="anchor" id="autotoc_md314"></a>
Generate the TensorFlow Lite File with Quantization</h3>
<p><a href="https://en.wikipedia.org/wiki/Quantization">Quantization</a> is a tricky and involved process, and it's still very much an active area of research, so taking the float graph that we've trained so far and converting it down to eight bit takes quite a bit of code. You can find more of an explanation of what quantization is and how it works in the chapter on latency optimization, but here we'll show you how to use it with the model we've trained. The majority of the code is preparing example images to feed into the trained network, so that the ranges of the activation layers in typical use can be measured. We rely on the TFLiteConverter class to handle the quantization and conversion into the TensorFlow Lite FlatBuffer file that we need for the on-device inference engine.</p>
<div class="fragment"><div class="line">import tensorflow.compat.v1 as tf</div>
<div class="line">import io</div>
<div class="line">import PIL</div>
<div class="line">import numpy as np</div>
<div class="line"> </div>
<div class="line">def representative_dataset_gen():</div>
<div class="line"> </div>
<div class="line">  record_iterator =</div>
<div class="line">tf.python_io.tf_record_iterator(path=&#39;person_detection_dataset/val.record-00000-of-00010&#39;)</div>
<div class="line"> </div>
<div class="line">  for _ in range(250):</div>
<div class="line">    string_record = next(record_iterator)</div>
<div class="line">    example = tf.train.Example()</div>
<div class="line">    example.ParseFromString(string_record)</div>
<div class="line">    image_stream =</div>
<div class="line">io.BytesIO(example.features.feature[&#39;image/encoded&#39;].bytes_list.value[0])</div>
<div class="line">    image = PIL.Image.open(image_stream)</div>
<div class="line">    image = image.resize((96, 96))</div>
<div class="line">    image = image.convert(&#39;L&#39;)</div>
<div class="line">    array = np.array(image)</div>
<div class="line">    array = np.expand_dims(array, axis=2)</div>
<div class="line">    array = np.expand_dims(array, axis=0)</div>
<div class="line">    array = ((array / 127.5) - 1.0).astype(np.float32)</div>
<div class="line">    yield([array])</div>
<div class="line"> </div>
<div class="line">converter =</div>
<div class="line">tf.lite.TFLiteConverter.from_frozen_graph(&#39;person_detection_frozen_graph.pb&#39;,</div>
<div class="line">[&#39;input&#39;], [&#39;MobilenetV1/Predictions/Reshape_1&#39;])</div>
<div class="line">converter.optimizations = [tf.lite.Optimize.DEFAULT]</div>
<div class="line">converter.representative_dataset = representative_dataset_gen</div>
<div class="line">converter.target_spec.supported_ops = [tf.lite.OpsSet.TFLITE_BUILTINS_INT8]</div>
<div class="line">converter.inference_input_type = tf.int8</div>
<div class="line">converter.inference_output_type = tf.int8</div>
<div class="line"> </div>
<div class="line">tflite_quant_model = converter.convert()</div>
<div class="line">open(&quot;person_detection_model.tflite&quot;, &quot;wb&quot;).write(tflite_quant_model)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md315"></a>
Generate the C source file</h3>
<p>The converter writes out a file, but most embedded devices don't have a file system. To access the serialized data from our program, we have to compile it into the executable and store it in Flash. The easiest way to do that is to convert the file into a C data array.</p>
<div class="fragment"><div class="line"># Install xxd if it is not available</div>
<div class="line">! apt-get -qq install xxd</div>
<div class="line"># Save the file as a C source file</div>
<div class="line">! xxd -i person_detection_model.tflite &gt; person_detect_model_data.cc</div>
</div><!-- fragment --><p>You can now replace the existing <code>person_detect_model_data.cc</code> file with the version you've trained, and be able to run your own model on embedded devices.</p>
<h1><a class="anchor" id="autotoc_md316"></a>
Other resources</h1>
<h2><a class="anchor" id="autotoc_md317"></a>
Training for a different category</h2>
<p>To customize your model you can update the <code>foreground_class_of_interest</code> to one of the 80 categories from the COCO dataset and adjust the threshold by modifying <code>small_object_area_threshold</code>. Here's an example that looks for cars:</p>
<div class="fragment"><div class="line">! python models/research/slim/download_and_convert_data.py \</div>
<div class="line">--logtostderr \</div>
<div class="line">--dataset_name=visualwakewords \</div>
<div class="line">--dataset_dir=car_dataset \</div>
<div class="line">--foreground_class_of_interest=&#39;car&#39; \</div>
<div class="line">--small_object_area_threshold=0.005</div>
</div><!-- fragment --><p>If the kind of object you're interested in isn't present in MS-COCO, you may be able to use transfer learning to help you train on a custom dataset you've gathered, even if it's much smaller. We don't have an example of this yet, but we hope to share one soon.</p>
<h2><a class="anchor" id="autotoc_md318"></a>
Understanding the Model Architecture</h2>
<p><a href="https://arxiv.org/abs/1704.04861">MobileNets</a> are a family of architectures designed to provide good accuracy for as few weight parameters and arithmetic operations as possible. There are now multiple versions, but in our case we're using the original v1 since it required the smallest amount of RAM at runtime. The core concept behind the architecture is depthwise separable convolution. This is a variant of classical two-dimensional convolutions that works in a much more efficient way, without sacrificing very much accuracy. Regular convolution calculates an output value based on applying a filter of a particular size across all channels of the input. This means the number of calculations involved in each output is width of the filter multiplied by height, multiplied by the number of input channels. Depthwise convolution breaks this large calculation into separate parts. First each input channel is filtered by one or more rectangular filters to produce intermediate values. These values are then combined using pointwise convolutions. This dramatically reduces the number of calculations needed, and in practice produces similar results to regular convolution.</p>
<p>MobileNet v1 is a stack of 14 of these depthwise separable convolution layers with an average pool, then a fully-connected layer followed by a softmax at the end. We've specified a 'width multiplier' of 0.25, which has the effect of reducing the number of computations down to around 60 million per inference, by shrinking the number of channels in each activation layer by 75% compared to the standard model. In essence it's very similar to a normal convolutional neural network in operation, with each layer learning patterns in the input. Earlier layers act more like edge recognition filters, spotting low-level structure in the image, and later layers synthesize that information into more abstract patterns that help with the final object classification. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>

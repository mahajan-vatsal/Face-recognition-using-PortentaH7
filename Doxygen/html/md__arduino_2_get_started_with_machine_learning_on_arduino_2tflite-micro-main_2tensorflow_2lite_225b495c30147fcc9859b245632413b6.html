<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Machine Vision using Portenta H7: 001_preallocated_tensors</title>
<link rel="icon" href="logo.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Machine Vision using Portenta H7<span id="projectnumber">&#160;2</span>
   </div>
   <div id="projectbrief">This project aims to develop a face recognition-based access control system using the Arduino Portenta H7 and Vision Shield, leveraging Edge Impulse for machine learning. The system captures facial images, processes them locally using an AI model deployed on the Portenta H7 and determines access based on authorised personnel.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">001_preallocated_tensors</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li>Pre-allocated tensors<ul>
<li>Background</li>
<li>Current status</li>
<li>Proposed implementation</li>
<li>Performance overview<ul>
<li>Cycle aspect</li>
<li>Memory aspect</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md234"></a>
Pre-allocated tensors</h1>
<h2><a class="anchor" id="autotoc_md235"></a>
Background</h2>
<p>Tensors are allocated differently depending on the type of tensor. Weight tensors are located in the flatbuffer, which is allocated by the application that calls TensorFlow Lite Micro. EvalTensors are allocated in the tensor arena, either offline planned as specified in the flatbuffers metadata (described in this <a href="https://docs.google.com/document/d/16aTSHL5wxsq99t6adVbBz1U3K8Y5tBDAvs16iroZDEU">RFC</a>), or allocated during runtime by the <a href="https://github.com/tensorflow/tflite-micro/tree/main/tensorflow/lite/micro/memory_planner">memory planner</a> (online planned), see <a href="https://docs.google.com/document/d/1akpqu0uiPQshmCrnV6dOEFgYM4tCCnI8Zce85PnjHMI">RFC</a>. The tensor arena is allocated by MicroAllocator in TensorFlow Lite Micro, and the model buffer (represented by a .tflite-file) is allocated by the application using TensorFlow Lite Micro. An illustration of this can be seen in the image below.</p>
<p><img src="../images/preallocated_tensors/preallocated_tensors_bg_1.png" alt="Image of two blocks" class="inline"/></p>
<p>Is some use cases it could be advantageous to place some of the EvalTensors outside of the tensor arena, for example: * When sensor output data is stored in its own defined buffer, outside the tensor arena, and therefore needs to be copied into the tensor arena before inference. * When the tensor is to be consumed from a memory location outside the tensor arena, e.g. a separate memory bank DSP. \ Details regarding the impact on the number of clock cycles and memory consumption can be found under “Performance overview”. In this RFC we present an option to allow an application to provide pre-allocated buffers to TensorFlow Lite Micro for selected tensors. An illustration of the resulting memory layout with pre-allocated tensors can be seen in the figure below.</p>
<p><img src="../images/preallocated_tensors/preallocated_tensors_bg_2.png" alt="Image of three blocks" class="inline"/></p>
<h2><a class="anchor" id="autotoc_md236"></a>
Current status</h2>
<p>The purpose of pre-allocating tensors is to reduce the number of clock cycles, and our initial motivation for this feature was that avoiding the copying of the buffer described in the Background section would reduce the number of cycles consumed by the application.</p>
<p>Our second motivation was that by using a buffer outside of the memory arena, there was an opportunity to significantly reduce the required size of the memory arena.</p>
<p>An initial investigation into these matters, using the person detection model as an example, indicates that the performance gain might not be very significant in many use cases. The reduction in the number of clock cycles looks to be ~1%. Details regarding this can be found in the Performance overview section.</p>
<p>The reduction in the size of the memory arena is not straightforward to estimate. As described in the Performance overview section, it depends on the size of other tensors in the network. In the worst case scenario it might not reduce the memory arena size at all. If the pre allocated buffer is much larger than the second largest buffer, then the reduction in size may be significant.</p>
<p>Therefore, our current position is that the performance gain expected from pre allocating the tensors does not motivate the increased complexity that this feature would introduce to the TensorFlow Lite Micro framework.</p>
<h2><a class="anchor" id="autotoc_md237"></a>
Proposed implementation</h2>
<p>MicroAllocator initializes all tensors to nullptr, and during the allocation process only allocates the tensors whose data field is nullptr. The application tells the MicroInterpreter which tensor is preallocated, and supplies a memory buffer using the RegisterPreallocatedTensor() function.</p>
<p>The MicroInterpreter then assigns the pre-allocated buffer to the tensor data-field. If the tensor in question is marked as offline planned, as described in this <a href="https://docs.google.com/document/d/16aTSHL5wxsq99t6adVbBz1U3K8Y5tBDAvs16iroZDEU">RFC</a>, the MicroInterpreter should not pre-allocated it, and instead return an error.</p>
<p>If multiple tensors are to be pre-allocated, multiple calls to RegisterPreallocatedTensor() are required. An example can be seen in the MSC below.</p>
<p><img src="../images/preallocated_tensors/preallocated_tensors_impl1.png" alt="MSC" class="inline"/></p>
<h2><a class="anchor" id="autotoc_md238"></a>
Performance overview</h2>
<h3><a class="anchor" id="autotoc_md239"></a>
Cycle aspect</h3>
<p>In this section we try to estimate the number of clock cycles one memcpy() takes in relation to the total inference time for the person_detection model. The reason for looking closer at this model is that it has a relatively large input data size, which should make the cycle consumption of a memcpy() relatively large. Please note that these numbers are approximate and based on calculations, not actual benchmarking numbers.</p>
<p>A word aligned memcpy() consumes somewhere between 1 - 4 bytes per cycle depending on which CPU is used. The input size for the person_detection model is 96x96 = 9216 bytes. On a reference system without accelerators one memcpy() of 9216 bytes corresponds to, in order of magnitudes, ~0.01% of the total amount of clock cycles for one inference. The ratio will differ depending on the input size and the number of inferences/second.</p>
<p>When using an accelerator, the total inference time will be significantly less which means that the memcpy()-call will consume a larger part of the total inference time. Approximations show that one memcpy() of 9216 bytes will consume ~1% of the total execution time for a reference system utilizing an ML HW accelerator.</p>
<h3><a class="anchor" id="autotoc_md240"></a>
Memory aspect</h3>
<p>In this section we'll look at memory savings aspects of pre-allocating tensors outside the tensor arena. The default memory planner in TFLu is <a href="https://github.com/tensorflow/tflite-micro/blob/main/tensorflow/lite/micro/memory_planner/greedy_memory_planner.h">GreedyPlanner</a> (see <a href="https://docs.google.com/document/d/1akpqu0uiPQshmCrnV6dOEFgYM4tCCnI8Zce85PnjHMI">RFC</a>). One good tool for understanding tensor layout in the tensor arena is using <a href="https://github.com/tensorflow/tflite-micro/blob/73c5fa4d2bfbfd974552957818de2ab18ff42f39/tensorflow/lite/micro/memory_planner/greedy_memory_planner.h#L84">PrintMemoryPlan API</a>. If we print the calculated memory layout for the <a href="https://storage.googleapis.com/download.tensorflow.org/data/tf_lite_micro_person_data_int8_grayscale_2020_06_23.zip">person detection model</a>, the tensor arena looks like this at each layer:</p>
<p><code>Layer 1: 00000000000000000000000000tttttttttttttt........................................ Layer 2: 00000000000000000000000000...........................999999999999999999999999999 Layer 3: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa999999999999999999999999999 Layer 4: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbb.............. Layer 5: cccccccccccccccccccccccccc...........................bbbbbbbbbbbbb.............. Layer 6: ccccccccccccccccccccccccccddddddddddddddddddddddddddd...........................</code></p>
<p>The horizontal axis shows offset from the start of the tensor arena. The vertical axis shows execution order. The dots are "unused" memory for that specific layer. The letters and numbers represent the EvalTensor index, mapped to 0-9, then a-z. 't' is the input tensor of layer 1 (equivalent to the input data to the model) and '0' is the output tensor of layer 1. Hence, '0' is also the input tensor to layer 2, and '9' is the output tensor of layer 2. And so on.</p>
<p>The reason for showing this illustration is that it becomes obvious that it is <b>the largest combination of simultaneously used tensors, of your model, that defines how large the tensor arena needs to be.</b> In this example, it's Layer 3.</p>
<p>The combined size of tensors 'a' and '9' defines the size needed for the tensors arena. As a consequence, to save tensor arena memory by pre-allocation, we must start by pre-allocating tensor 'a' or '9' outside the arena. This will make the total size of the tensor arena smaller, which will reduce the total memory footprint of TensorFlow Lite Micro if the pre-allocated tensor is already allocated outside of the memory arena, like in the examples given in the Background section. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>

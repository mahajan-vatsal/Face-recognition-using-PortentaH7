<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Machine Vision using Portenta H7: optimized_kernel_implementations</title>
<link rel="icon" href="logo.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Machine Vision using Portenta H7<span id="projectnumber">&#160;2</span>
   </div>
   <div id="projectbrief">This project aims to develop a face recognition-based access control system using the Arduino Portenta H7 and Vision Shield, leveraging Edge Impulse for machine learning. The system captures facial images, processes them locally using an AI model deployed on the Portenta H7 and determines access based on authorised personnel.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">optimized_kernel_implementations</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li>Summary</li>
<li>High-Level Steps<ul>
<li>Why not Optimize the Reference Kernels</li>
</ul>
</li>
<li>Software Architecture<ul>
<li>Hardware-specific NN library</li>
<li>Optimized Kernels</li>
<li>Build System Integration</li>
<li>Testing and Continuous Integration</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md187"></a>
Summary</h1>
<p>This guide describes the recommended high-level architecture and steps to add hardware-specific optimized kernels to TfLite Micro.</p>
<p>The goal with these optimizations and the process that we recommend to getting them merged into the TfLite Micro codebase is to have a measurable and documented performance improvement on a benchmark of interest.</p>
<p>Once the optimizations are merged, they will indeed be used for more than the benchmark but the context for why the optimizations were added is still very important.</p>
<h1><a class="anchor" id="autotoc_md188"></a>
High-Level Steps</h1>
<ol type="1">
<li>Pick a benchmark that you would like to measure the performance for.<ul>
<li>Existing benchmarks are in the <a href="../benchmarks">benchmarks directory</a>.</li>
<li>If none of the existing benchmarks capture your use-case, then please create a github issue or start a thread on <a href="#" onclick="location.href='mai'+'lto:'+'mic'+'ro'+'@te'+'ns'+'orf'+'lo'+'w.o'+'rg'; return false;">micro<span class="obfuscator">.nosp@m.</span>@ten<span class="obfuscator">.nosp@m.</span>sorfl<span class="obfuscator">.nosp@m.</span>ow.o<span class="obfuscator">.nosp@m.</span>rg</a> to figure out how to add in a new benchmark.</li>
<li>If adding a publicly-available benchmark to the TFLM codebase is determined to be infeasible, then a fall-back would be to have an internal benchmark that can be used to document the benefits of adding in the optimizations via PR descriptions.</li>
<li>Adding optimized code without any associated benchmarks will need very strong justification and will most likely not be permitted.</li>
</ul>
</li>
</ol>
<ol type="1">
<li>Do the groundwork and architecture needed to be able to add in optimizations for your target (more details in the software architecture section).</li>
</ol>
<ol type="1">
<li>Create one pull request for each optimized kernel with the PR description clearly stating the commands that were used to measure the performance improvement.<ul>
<li>This context is important even if the toolchain is proprietary and there are currently a small number of users.<ul>
<li>See <a href="https://github.com/tensorflow/tensorflow/pull/47098">this PR</a> as an example.</li>
<li>At minimum the latency with and without the particular optimized kernel should be documented. <a href="https://github.com/tensorflow/tensorflow/pull/46746">Additional context</a> may also be desirable.</li>
</ul>
</li>
<li>Here is some <a href="https://testing.googleblog.com/2017/09/code-health-providing-context-with.html">general guidance</a> on writing <a href="https://google.github.io/eng-practices/review/developer/cl-descriptions.html">good PR descriptions</a></li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md189"></a>
Why Not Optimize the Portable Reference Kernels?</h2>
<p>We would like to explicitly point out (as have others) that the reference kernel implementations are not performant and there are plenty of opportunities to speed them up. This is by design and the reference kernels are meant to be a shared starting point to then be optimized in a target specific optimized kernel implementation.</p>
<p>Two previous discussions on this topic are on <a href="https://github.com/tensorflow/tensorflow/pull/42477">PR #42477</a> and <a href="https://github.com/tensorflow/tensorflow/pull/45227">PR #45227</a></p>
<p>Our current point of view on this topic is that while optimizing shared reference code in a portable manner is attractive, we are making an explicit choice to not go down that path and instead rely on target-specific optimized implementations. The TFLM codebase has a growing list of optimized kernel implementations, and we are investing in making the process of adding new implementations smoother.</p>
<h1><a class="anchor" id="autotoc_md190"></a>
Software Architecture</h1>
<p>The optimized kernel architecture is composed of the following three modules:</p>
<ol type="1">
<li>Hardware-specific NN library</li>
</ol>
<ol type="1">
<li>Optimized Kernels</li>
</ol>
<ol type="1">
<li>Build System Integration</li>
</ol>
<h2><a class="anchor" id="autotoc_md191"></a>
Hardware-specific NN library</h2>
<p>This library uses knowledge of the hardware and compiler to implement the underlying operations. Examples of this are <a href="https://github.com/ARM-software/CMSIS_5/tree/develop/CMSIS/NN">CMSIS-NN</a> from ARM and <a href="https://github.com/foss-xtensa/nnlib-hifi4">NNLib</a> from Cadence.</p>
<p>The benefits of having this API separation are:</p>
<ol type="1">
<li>The NN library does not need to follow the style guide of the rest of the TFLM code.</li>
</ol>
<ol type="1">
<li>Releases of the NN library can be made independent of TFLM</li>
</ol>
<ol type="1">
<li>The same NN library can be used and tested independent of TFLM.</li>
</ol>
<ol type="1">
<li>The maintainers of the NN library have full control over the development process that they would like to follow.</li>
</ol>
<h2><a class="anchor" id="autotoc_md192"></a>
Optimized Kernels</h2>
<p>These will be (hopefully thin) wrappers that act as the glue between TFLM and the NN library.</p>
<p>The goal here is to delegate as much work as possible to the NN library while still allowing the two APIs (TFLM and NN library) to be independent of each other. If there is a performance degradation due to this (for example, unnecessary memory copies) then we can evaluate those on a case-by-case basis.</p>
<p>This code will be reviewed and merged in the TFLM github repository and must follow the development style of the TFLM codebase.</p>
<p>Some amount of refactoring of the existing code may be needed to ensure that code is suitably shared between the reference and optimized kernels. There is currently no fixed recipe for this refactor and we will evaluate on a case-by-case basis during the PR review.</p>
<p>For example, to add an optimized implementation for <code>fully_conntected</code> for the Xtensa Fusion F1 the steps were:</p><ul>
<li><a href="https://github.com/tensorflow/tensorflow/pull/45464">PR 1</a>: refactor for reference fallbacks and a baseline latency.</li>
<li><a href="https://github.com/tensorflow/tensorflow/pull/46242">PR 2</a>: refactor to share code between reference and optimized kernels.</li>
<li><a href="https://github.com/tensorflow/tensorflow/pull/46411">PR 3</a>: add the code needed to use the optimized NN lib and document the latency improvement.</li>
</ul>
<h2><a class="anchor" id="autotoc_md193"></a>
Build System Integration</h2>
<p>This module is the least defined but we strongly recommend the following: 1. A single target makefile.inc for all the architectures that you would like to support along with optional target-specific <a href="../cortex_m_corstone_300/system_setup.cc">system_setup.cc</a>. See <a href="../tools/make/targets/cortex_m_generic_makefile.inc">cortex_m_generic_makefile.inc</a> and <a href="../tools/make/targets/xtensa_makefile.inc">xtensa_makefile.inc</a> as examples.</p>
<ol type="1">
<li>A single <code>ext_libs.inc</code> (and associated scripts) that downloads any external dependencies (including the NN library). For example:<ul>
<li><a href="../tools/make/ext_libs/cmsis_nn.inc">cmsis_nn.inc</a> and <a href="../tools/make/ext_libs/cmsis_download.sh">cmsis_download.sh</a></li>
<li><a href="../tools/make/ext_libs/xtensa.inc">xtensa.inc</a> and <a href="../tools/make/ext_libs/xtensa_download.sh">xtensa_download.sh</a></li>
</ul>
</li>
</ol>
<ol type="1">
<li>The optimized kernels will then live in a kernels subdirectory (e.g. <a href="../kernels/cmsis_nn">kernels/cmsis_nn</a> and <a href="../kernels/xtensa">kernels/xtensa</a>)</li>
</ol>
<p>Two development workflows that the TFLM team would like to encourage and support:</p>
<ol type="1">
<li>Export static library + headers into target-specific development environment<ul>
<li>Build a static libtensorflow-microlite.a using the TFLM makefile with: <code>make -f tensorflow/lite/micro/tools/make/Makefile TARGET=&lt;target&gt; OPTIMIZED_KERNEL_DIR=&lt;optimize_dir&gt; microlite</code></li>
<li>Use the static library and any TFLM headers as part of the overall application (with its own build system).</li>
</ul>
</li>
</ol>
<ol type="1">
<li>Integrate TFLM with IDE:<ul>
<li>This has historically been done using the TFLM Makefile’s support for project generation.</li>
<li>However, given the learning curve and high-maintenance overhead, we are moving away from supporting project generation via the Makefile and are encouraging future IDE integrations to be done outside of the TFLM Makefiles.</li>
<li>The TFLM team is currently working through the details on this topic.</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md194"></a>
Testing and Continuous Integration</h2>
<p>The kernel tests are the primary method of ensuring that the optimized kernel implementations are accurate.</p>
<p>Currently, most of the tests require the optimizations to be bit-exact to the quantized reference implementation. We can revisit this requirement if it ends up having a high associated cost on the latency.</p>
<p>We strongly encourage optimized kernel implementations to have an associated continuous build that runs through all the unit tests and publishes a build badge to the <a href="../README.md#community-supported-builds">TFLM community supported builds</a> table. Running the units tests once a day is often a good place to start. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
